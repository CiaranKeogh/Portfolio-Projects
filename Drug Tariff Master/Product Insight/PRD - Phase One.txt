Project: Drug Tariff Master

Goal: Create an automated system that processes NHS Dictionary of Medicines and Devices (dm+d) data. The MVP focuses on downloading specified dm+d XML files, storing them in an SQLite database with correctly defined relationships and integrated lookup data, and providing basic search capabilities on a combined dataset.

Core Components of MVP:

Download Handling: Get required files (f_vtm2.xml, f_vmp2.xml, f_vmpp2.xml, f_amp2.xml, f_ampp2.xml, f_gtin2.xml, f_lookup.xml).

Database Creation: Set up an SQLite database with tables corresponding to XML structures.

Relationship Implementation: Define and enforce Primary Key (PK) and Foreign Key (FK) relationships between tables.

Data Parsing & Loading: Read XML files and insert data into database tables, respecting dependencies and constraints.

Lookup Integration: Populate descriptive fields by joining main data tables with lookup tables.

Search Data Preparation: Create a denormalized table (search_data) for efficient searching.

Basic Search: Implement a simple Command Line Interface (CLI) search tool.

Cohesive MVP Implementation Plan

Phase 0: Preparation & Setup (Estimated Time: 0.5 days)

Environment Setup:

Install Python (3.8+ recommended).

Install necessary Python libraries: requests, lxml, sqlite3.

Set up project directory: src/, data/raw/, logs/, schemas/.

Store provided XSD files (renamed to .xsd) in schemas/.

Obtain Credentials: Secure TRUD API key (use environment variable or secure config).

Review Documentation: Thoroughly review PRD, Technical Specification (especially Appendix A for field details and lookup mappings), and XSD structures.

Phase 1: Download Mechanism (Manual Trigger) (Estimated Time: 1 day)

Develop Download Script (download_dmd.py):

Use requests library.

Call TRUD releases API endpoint to get archiveFileUrl.

Download the main ZIP file.

Implement error handling (retries, logging to logs/download.log).

Extract main ZIP content to data/raw/.

Handle Nested GTIN Zip: Add logic to find and extract f_gtin2.xml and its XSD from the nested ZIP within the main download into data/raw/.

Verify Target Files: Ensure the script confirms the presence of required .xml and .xsd files (vtm, vmp, amp, vmpp, ampp, lookup, gtin). Optionally include ingredient files.

Manual Execution: Script will be run manually for the MVP.

Phase 2: Database Schema Definition (Estimated Time: 2 days)

Analyze XSDs & Tech Spec: Review structures to define necessary tables.

Define Tables: Plan CREATE TABLE statements for:

Core Entities: vtm, vmp, amp, vmpp, ampp.

Detail/Linking Tables: vmp_ingredient, vmp_ont_drug_form, vmp_drug_form, vmp_drug_route, vmp_control_drug_info, amp_ingredient, amp_licensed_route, amp_information, vmpp_drug_tariff_info, vmpp_comb_content, ampp_pack_info, ampp_prescrib_info, ampp_price_info, ampp_reimb_info, ampp_comb_content, gtin. (Optional: ingredient table).

Lookup Tables: Create separate tables for each main section within f_lookup.xml (e.g., lookup_supplier, lookup_form, lookup_route, lookup_unit_of_measure, lookup_legal_category, lookup_dt_payment_category, lookup_basis_of_name, etc.). Use CD as the primary key. Include other fields like DESC, CDDT, CDPREV, INVALID as defined by InfoType, HistoryInfoType, SupplierInfoType.

Define Columns & Types: Map XML elements to SQL columns using appropriate SQLite types (INTEGER, TEXT, REAL). Use TEXT for dates (YYYY-MM-DD).

Define Constraints (PKs, FKs, NOT NULL):

Primary Keys (PK): Identify main IDs (e.g., VTMID, VPID, APID, VPPID, APPID, ISID, lookup CDs). Use composite keys where necessary (linking tables).

Foreign Keys (FK): Based strictly on XSDs and Technical Specification, implement the following relationships (SourceTable.ForeignKeyColumn -> TargetTable.PrimaryKeyColumn):

Core Entity Relationships:

vmp.VTMID -> vtm.VTMID

amp.VPID -> vmp.VPID

vmpp.VPID -> vmp.VPID

ampp.APID -> amp.APID

ampp.VPPID -> vmpp.VPPID

VMP & Detail Table Relationships:

vmp.BASISCD -> lookup_basis_of_name.CD

vmp.BASIS_PREVCD -> lookup_basis_of_name.CD

vmp.NMCHANGECD -> lookup_namechange_reason.CD

vmp.COMBPRODCD -> lookup_combination_prod_ind.CD

vmp.PRES_STATCD -> lookup_virtual_product_pres_status.CD

vmp.NON_AVAILCD -> lookup_virtual_product_non_avail.CD

vmp.DF_INDCD -> lookup_df_indicator.CD

vmp.UDFS_UOMCD -> lookup_unit_of_measure.CD

vmp.UNIT_DOSE_UOMCD -> lookup_unit_of_measure.CD

vmp_ingredient.VPID -> vmp.VPID

vmp_ingredient.ISID -> ingredient.ISID (if ingredient table is used)

vmp_ingredient.BASIS_STRNTCD -> lookup_basis_of_strnth.CD

vmp_ingredient.BS_SUBID -> ingredient.ISID (if ingredient table is used)

vmp_ingredient.STRNT_NMRTR_UOMCD -> lookup_unit_of_measure.CD

vmp_ingredient.STRNT_DNMTR_UOMCD -> lookup_unit_of_measure.CD

vmp_ont_drug_form.VPID -> vmp.VPID

vmp_ont_drug_form.FORMCD -> lookup_ont_form_route.CD

vmp_drug_form.VPID -> vmp.VPID

vmp_drug_form.FORMCD -> lookup_form.CD

vmp_drug_route.VPID -> vmp.VPID

vmp_drug_route.ROUTECD -> lookup_route.CD

vmp_control_drug_info.VPID -> vmp.VPID

vmp_control_drug_info.CATCD -> lookup_control_drug_category.CD

vmp_control_drug_info.CAT_PREVCD -> lookup_control_drug_category.CD

AMP & Detail Table Relationships:

amp.SUPPCD -> lookup_supplier.CD

amp.LIC_AUTHCD -> lookup_licensing_authority.CD

amp.LIC_AUTH_PREVCD -> lookup_licensing_authority.CD

amp.LIC_AUTHCHANGECD -> lookup_licensing_authority_change_reason.CD

amp.COMBPRODCD -> lookup_combination_prod_ind.CD

amp.FLAVOURCD -> lookup_flavour.CD

amp.AVAIL_RESTRICTCD -> lookup_availability_restriction.CD

amp_ingredient.APID -> amp.APID

amp_ingredient.ISID -> ingredient.ISID (if ingredient table is used)

amp_ingredient.UOMCD -> lookup_unit_of_measure.CD

amp_licensed_route.APID -> amp.APID

amp_licensed_route.ROUTECD -> lookup_route.CD

amp_information.APID -> amp.APID

amp_information.COLOURCD -> lookup_colour.CD

VMPP & Detail Table Relationships:

vmpp.QTY_UOMCD -> lookup_unit_of_measure.CD

vmpp.COMBPACKCD -> lookup_combination_pack_ind.CD

vmpp_drug_tariff_info.VPPID -> vmpp.VPPID

vmpp_drug_tariff_info.PAY_CATCD -> lookup_dt_payment_category.CD

vmpp_comb_content.PRNTVPPID -> vmpp.VPPID

vmpp_comb_content.CHLDVPPID -> vmpp.VPPID

AMPP & Detail Table Relationships:

ampp.COMBPACKCD -> lookup_combination_pack_ind.CD

ampp.LEGAL_CATCD -> lookup_legal_category.CD

ampp.DISCCD -> lookup_discontinued_ind.CD

ampp_pack_info.APPID -> ampp.APPID

ampp_pack_info.REIMB_STATCD -> lookup_reimbursement_status.CD

ampp_pack_info.REIMB_STATPREVCD -> lookup_reimbursement_status.CD

ampp_prescrib_info.APPID -> ampp.APPID

ampp_price_info.APPID -> ampp.APPID

ampp_price_info.PRICE_BASISCD -> lookup_price_basis.CD

ampp_reimb_info.APPID -> ampp.APPID

ampp_reimb_info.SPEC_CONTCD -> lookup_spec_cont.CD

ampp_reimb_info.DND -> lookup_dnd.CD

ampp_comb_content.PRNTAPPID -> ampp.APPID

ampp_comb_content.CHLDAPPID -> ampp.APPID

GTIN Table Relationships:

gtin.AMPPID -> ampp.APPID

NOT NULL: Apply to columns with minOccurs="1" in XSDs. Allow NULLs for optional FKs.

Create Database Script (setup_database.py):

Script connects to/creates SQLite file (e.g., dmd.db).

Drops existing tables (optional).

Executes all CREATE TABLE statements including all PK and FK constraints defined above.

Log success/failure.

Phase 3: Data Parsing & Loading (Estimated Time: 3 days)

Develop Parser Script (load_data.py):

Define Loading Order (CRUCIAL - Must respect FK constraints defined in Phase 2):

Lookup Tables (f_lookup.xml -> lookup_* tables)

(Optional: Ingredient (f_ingredient2.xml -> ingredient))

VTM (f_vtm2.xml -> vtm)

VMP (f_vmp2.xml -> vmp and related vmp_* detail tables)

AMP (f_amp2.xml -> amp and related amp_* detail tables)

VMPP (f_vmpp2.xml -> vmpp and related vmpp_* detail tables)

AMPP (f_ampp2.xml -> ampp and related ampp_* detail tables)

GTIN (f_gtin2.xml -> gtin)

Implement XML Parsing (using lxml.etree):

For each XML file in the correct loading order:

(Recommended) Validate XML against its XSD. Log errors.

Use iterparse for memory efficiency.

Extract data for main elements and children. When parsing nested/detail elements, ensure the parent ID (e.g., VPID, APID) is extracted to satisfy the FK link during insertion.

Handle missing optional elements (insert NULL). Convert data types.

Implement Database Insertion:

Connect to dmd.db.

Clear Data: DELETE from tables in reverse loading order before inserting new data.

Use prepared statements (INSERT INTO ... VALUES (?, ?, ...)).

Implement chunking (~1000 records) using executemany.

Handle/log data errors (constraint violations).

Commit transactions periodically.

Logging: Log progress, record counts, errors to logs/load_data.log.

Phase 4: Search Data Preparation (Estimated Time: 1 day)

Define search_data Structure: Include key fields for searching (IDs, Names, Descriptions from core entities, aggregated GTINs, and relevant lookup descriptions). E.g.:

AMPP_ID, AMPP_NM, AMP_ID, AMP_NM, AMP_DESC, VMPP_ID, VMPP_NM, VMP_ID, VMP_NM, VTM_ID, VTM_NM, GTINs (TEXT), Supplier_NM, LegalCategory_DESC, etc.

Create search_data Table: Add DROP TABLE IF EXISTS search_data; and CREATE TABLE search_data (...); to setup_database.py (or a separate script).

Populate search_data Table:

In load_data.py (after all base tables are loaded), execute a complex INSERT INTO search_data SELECT ... SQL statement.

This statement will heavily rely on the relationships defined in Phase 2, using JOINs (e.g., ampp JOIN amp ON ampp.APID = amp.APID JOIN vmpp ON ampp.VPPID = vmpp.VPPID JOIN vmp ON vmpp.VPID = vmp.VPID JOIN vtm ON vmp.VTMID = vtm.VTMID).

Use LEFT JOINs to the necessary lookup_* tables (identified via the FKs in Phase 2) to fetch descriptions (DESC columns).

Use GROUP BY ampp.APPID (and other necessary fields) and GROUP_CONCAT(gtin.GTIN) to aggregate GTINs.

Create Indexes: Add CREATE INDEX statements in setup_database.py for search_data columns used in searching (e.g., AMPP_NM, AMP_NM, VMPP_NM, VMP_NM, AMP_DESC, IDs).

Phase 5: Basic Search Implementation (CLI) (Estimated Time: 0.5 days)

Develop Search Script (search_dmd.py):

Accepts command-line search terms.

Connects to dmd.db.

Constructs SELECT * FROM search_data WHERE ... using LIKE '%term%' for text fields and = for IDs.

Prints results clearly to the console.

Phase 6: Testing & Refinement (Estimated Time: 1 day)

Unit Testing: Test individual functions.

Integration Testing:

Run the full download->load->search_prep pipeline.

Verify data counts and integrity (check FK constraints hold).

Test search_data content and search_dmd.py functionality.

Refinement: Debug and optimize as needed.

Phase 7: Documentation (Estimated Time: 0.5 days)

README: Document setup, execution steps (download, load, search), schema overview (mentioning key relationships), API key handling.

Code Comments: Ensure code clarity.

Total Estimated MVP Time: ~9-10 days

Assumptions:

Python, SQL, XML proficiency.

TRUD API key available.

XSDs accurately represent received XML structure.

Full data replacement per cycle.

SQLite suitable for MVP performance.

CLI search is sufficient for MVP.

Key Considerations & Potential Challenges:

Performance: Large files require efficient parsing (lxml.iterparse) and batch inserts (executemany). Indexing is vital.

Data Quality: Source data might have inconsistencies; robust logging is needed. XSD validation helps mitigate structural issues.

Schema Evolution: Future dm+d changes may require updates.

Lookup Mapping: Correctly identifying and joining to the specific lookup table for each CD field is critical.

Constraint Strictness: Ensure FKs are correctly defined and the loading order strictly adheres to them.

This integrated plan provides a clear roadmap, embedding the crucial relationship details within the database design phase, ensuring they are foundational to the MVP build.